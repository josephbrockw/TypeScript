Awesome—here’s your full, beginner-friendly lesson. Follow it top-to-bottom and you’ll finish with a working TypeScript toolchain, a tiny program, and a “strict” compiler setup that mirrors real-world teams.

---

# Lesson: From Zero to “Hello TypeScript”

## What you’ll learn

* Install **Node LTS**, **pnpm**, **VS Code**, and **TypeScript**
* What TypeScript is (JavaScript + types + a compiler)
* Create and run `hello.ts` with **tsx**
* Compile with **tsc**
* Add a **strict** `tsconfig.json`
* Troubleshoot PATH and ESM/CJS pitfalls
* Verify with a **success checklist**

---

## 0) Install the tools

### A. Node LTS (includes npm)

* **macOS (Apple/Intel):**

  1. Install Homebrew if you don’t have it:
     `/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"`
  2. Install Node LTS:
     `brew install node@lts`
  3. Ensure it’s first on your PATH (often automatic with brew).
     Check: `node -v` (expect something like `v20.x` or `v22.x`).

* **Windows:**
  Download the LTS installer from nodejs.org and run it. Then open **PowerShell** and check:
  `node -v`

> If you already have Node installed, make sure it’s a recent **LTS** (not an ancient version). Anything ≥ 18 LTS is fine.

---

### B. pnpm (fast package manager)

* Install globally:

  ```bash
  corepack enable
  corepack prepare pnpm@latest --activate
  ```

  Check:

  ```bash
  pnpm -v
  ```

> If `corepack` is missing, update Node or: `npm i -g pnpm`

---

### C. VS Code

* Download from code.visualstudio.com.
* Recommended extensions:

  * **ESLint** (dbaeumer.vscode-eslint)
  * **Prettier** (esbenp.prettier-vscode)
  * **TypeScript ESLint** (optional; we’ll wire later)
* Open your project folder in VS Code when you create it below.

---

## 1) Make a fresh project

```bash
mkdir ts-hello && cd ts-hello
pnpm init -y
```

Add TypeScript + runner:

```bash
pnpm add -D typescript tsx @types/node
```

What are these?

* **typescript**: the compiler (`tsc`)
* **tsx**: dev runner for TypeScript/ESM—lets you run `.ts` files directly (great for scripts, examples)
* **@types/node**: types for Node’s APIs (fs, path, etc.)

---

## 2) What is TypeScript (TS) in one minute?

* **JavaScript + types + a compiler.**
  You still write JavaScript, but you add type information. TS’s compiler checks your code **before** it runs and then **erases** the types, emitting plain JS.
* TS **catches bugs early** (wrong shapes, wrong params, null/undefined issues).
* TS **does not** magically speed up your code; it improves **correctness** and **developer experience**.

---

## 3) Create `hello.ts`

Create `src/hello.ts`:

```ts
// src/hello.ts
function greet(name: string): string {
  return `Hello, ${name}!`;
}

console.log(greet("TypeScript"));
```

Run it with **tsx** (no build step):

```bash
pnpm dlx tsx src/hello.ts
```

You should see:

```
Hello, TypeScript!
```

> Why `tsx`? It runs TypeScript files directly in dev, handles ESM cleanly, and is perfect for tiny scripts and examples.

---

## 4) Initialize a tsconfig (strict on)

Create a **tsconfig.json** at the project root:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2020"],
    "strict": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist"
  },
  "include": ["src"]
}
```

Also add `"type": "module"` to **package.json** so Node treats output as ESM:

```json
{
  "name": "ts-hello",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "tsx src/hello.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/hello.js"
  }
}
```

Now try:

```bash
pnpm dev         # runs with tsx
pnpm build       # compiles to /dist with tsc
pnpm start       # runs compiled JS with Node
```

---

## 5) ESM vs CJS (don’t get tripped)

* **ESM** (modern): `import { x } from "./x.js"`, package `"type": "module"`, TS `module: "NodeNext"`.
* **CJS** (older): `const x = require("./x")`, package without `"type": "module"`, TS `module: "CommonJS"`.

**Pick one.** This lesson uses **ESM**. If you switch to CJS, change:

* `tsconfig.json` → `"module": "CommonJS", "moduleResolution": "Node"`
* Remove `"type": "module"` from package.json
* Change import styles accordingly.

---

## 6) Add a tiny type failure (and learn)

Edit `src/hello.ts`:

```ts
function greet(name: string): string {
  return `Hello, ${name}!`;
}

// @ts-expect-error - Intentional: Passing number instead of string
console.log(greet(42));
```

Run the compiler:

```bash
pnpm build
```

You’ll see an error like:

```
Argument of type 'number' is not assignable to parameter of type 'string'.
```

Fix it:

```ts
console.log(greet("42"));
```

Re-run:

```bash
pnpm build && pnpm start
```

---

## 7) Troubleshooting Cheat-Sheet

### “pnpm: command not found”

* Run: `corepack enable` then `corepack prepare pnpm@latest --activate`
* Or: `npm i -g pnpm`
* Check PATH: `echo $PATH` (macOS), `echo $env:Path` (Windows PowerShell)

### “tsx: command not found”

* Use `pnpm dlx tsx ...` (no global install needed), or add a script in package.json (`"dev": "tsx src/hello.ts"`), then `pnpm dev`.

### ESM import errors like “Cannot use import statement outside a module”

* Ensure package.json has `"type": "module"`.
* Use a modern TS config: `"module": "NodeNext", "moduleResolution": "NodeNext"`.
* When you import **compiled JS**, include the `.js` extension in ESM world.

### “TS2688: Cannot find type definition file for 'node'”

* You installed `@types/node`? `pnpm add -D @types/node`
* If using VS Code, restart TS server: `Cmd/Ctrl+Shift+P` → “TypeScript: Restart TS server”.

### “Cannot find module './something'”

* In ESM, ensure the compiled path ends with `.js` (TypeScript rewrites extensions). When importing TS within TS, bare paths are okay; at runtime with Node + ESM, output files need `.js`.

### “tsc builds nothing”

* Did you put source files under `src` and include `"include": ["src"]`?
* Is `"outDir": "dist"` set? Check `dist/` after `pnpm build`.

---

## 8) Your Success Checklist

By the end, you should be able to say “yes” to all of these:

* [ ] `node -v` shows an LTS version (≥ 18).
* [ ] `pnpm -v` works.
* [ ] `pnpm dev` prints `Hello, TypeScript!`.
* [ ] `pnpm build` creates `dist/hello.js`.
* [ ] `pnpm start` runs the compiled file with Node.
* [ ] Changing `name: string` to a wrong type triggers a TS compile error you can read and fix.
* [ ] You understand why we chose **ESM** and how to switch to **CJS** if required.
* [ ] You can explain in one sentence: *“TS is JS with types; the compiler checks at build time and emits plain JS.”*

---

## 9) Mini-Exercises (10–15 min)

1. **Add a second function** in `src/hello.ts`:

   ```ts
   function shout(msg: string): string {
     return msg.toUpperCase();
   }
   console.log(shout(greet("friend")));
   ```

   Run `pnpm dev`. Then deliberately pass a number to `shout` and fix the error.

2. **Introduce a union type**:

   ```ts
   type Name = string | { first: string; last: string };

   function greetAny(name: Name): string {
     if (typeof name === "string") return `Hello, ${name}!`;
     return `Hello, ${name.first} ${name.last}!`;
   }
   console.log(greetAny({ first: "Ada", last: "Lovelace" }));
   ```

   Verify it runs; then remove the narrowing and read the error, re-add the narrowing.

3. **Flip to CommonJS (optional)**

   * Remove `"type": "module"` from package.json.
   * Set `"module": "CommonJS", "moduleResolution": "Node"` in tsconfig.
   * Change imports to `require`/`module.exports` or run with `tsx --cjs`.
   * Build and run again. Then revert to ESM.

---

## 10) What’s next?

When this is solid, ask me to **Generate Step 2 (JavaScript → TypeScript Mental Model)** and we’ll build the intuition you’ll lean on daily (inference, structural typing, and where to annotate).

