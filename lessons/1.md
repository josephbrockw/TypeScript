# Lesson: JavaScript → TypeScript Mental Model

## What you’ll learn

* **Structural typing:** shapes, not names, determine compatibility.
* **Inference:** when TS can figure types out (and when it can’t).
* **Erasure:** types disappear at compile time—no runtime speed boosts.
* Why types catch bugs **early**, and what they **don’t** do.

---

## 0) Prep

Create a file for this step:

```bash
mkdir -p src
touch src/step2.ts
```

Add a script (optional) to `package.json`:

```json
{
  "scripts": {
    "step2": "tsx src/step2.ts",
    "typecheck": "tsc -p tsconfig.json --noEmit"
  }
}
```

Run with:

```bash
pnpm step2     # to execute
pnpm typecheck # to type-check without emitting JS
```

---

## 1) Structural typing (the “shape” rule)

In TS, **if two objects have the same shape, they’re compatible**, even if their type names differ. (This is different from “nominal” systems where names must match.)

### Code probe A — same shape, different names

```ts
// === Structural typing
type User = { id: string; name: string };
type Person = { id: string; name: string };

const u: User = { id: "u1", name: "Ada" };
const p: Person = u;             // OK: shapes match

// Add an extra field to User only
type UserWithEmail = { id: string; name: string; email: string };
const ue: UserWithEmail = { id: "u2", name: "Lin", email: "lin@example.com" };

// Assigning a "bigger" shape to a "smaller" variable can be OK when extra fields are allowed:
const p2: Person = ue;           // OK: Person needs id+name; ue has those (and more).

// But going the other way is not OK:
const ue2: UserWithEmail = p;    // ❌ Error: 'email' is missing
console.log(p2);
```

Run `pnpm typecheck` and read the error on `ue2`.

**Takeaway:** Types are **compatible by shape**, not by name.

### Code probe B — function parameter compatibility (bivariance pitfalls)

```ts
type Handler = (evt: { type: "click"; x: number; y: number }) => void;

const handle: Handler = (evt) => {
  console.log(evt.type, evt.x, evt.y);
};

const looser = (evt: { type: string }) => {}; // too loose to be safe as Handler
// const bad: Handler = looser; // ❌ Usually not assignable (safer with strict function types)
```

**Takeaway:** Be precise with function parameter shapes to avoid “I accepted less info than I need” bugs.

---

## 2) Inference (let TS do the work)

TypeScript *infers* many types from usage. You don’t need to annotate everything—especially **locals**. You **do** want explicit annotations at **boundaries** (public functions, exports, API shapes).

### Code probe C — basic inference & “widening”

```ts
// Inference from initializers:
const n = 42;        // n: 42 (a literal) if "const", otherwise number
let s = "hi";        // s: string (widened from "hi")

// Arrays infer union or common supertype:
const arr = [1, 2, 3];          // number[]
const mixed = [1, "two"];       // (string | number)[]

// Contextual typing from usage:
["a", "b", "c"].forEach(ch => ch.toUpperCase()); // ch inferred as string
```

### Code probe D — `as const` and literal inference

```ts
const STATUS = { Draft: "draft", Live: "live" } as const;
// STATUS.Draft has type "draft" (literal), not string
type Status = (typeof STATUS)[keyof typeof STATUS];

function publish(s: Status) { /* ... */ }
// publish("draft");  // OK
// publish("other");  // ❌ not assignable
```

**Takeaway:** `as const` preserves **literal** types and is great for discriminants and unions.

### Code probe E — when inference needs help

```ts
function pickFirst<T>(xs: T[]): T | undefined {
  return xs[0];
}

const x = pickFirst([1, 2, 3]);   // T inferred as number → x: number | undefined
const y = pickFirst([]);          // T inferred as never → y: never | undefined
// If you need a specific T when the array is empty, pass a type arg:
const z = pickFirst<string>([]);  // z: string | undefined
```

**Takeaway:** Inference follows usage. Sometimes you **hint** with a generic parameter.

---

## 3) Erasure (types vanish at runtime)

TypeScript **erases** types when compiling—your runtime is still plain JavaScript. That means:

* No runtime speed-ups from types alone.
* No runtime validation of inputs unless you add checks/schemas.
* Errors are caught **before** running (by the compiler), not **during**.

### Code probe F — what compiles to JS

```ts
type User = { id: string; name: string };

function hello(u: User): string {
  return `Hello, ${u.name}`;
}
console.log(hello({ id: "u1", name: "Grace" }));
```

Compile with `pnpm build`. Look at `dist/step2.js`—the `type User` annotation is **gone**.

### Code probe G — runtime still needs guards

```ts
// @ts-expect-error — pretend a bad call sneaks in:
console.log(hello({ id: 123, name: null }));

// If you FORCE it with "as any", the compiler shuts up, but runtime can explode:
const bad: any = { id: 123, name: null };
console.log(hello(bad)); // prints "Hello, null" — no type safety at runtime!
```

**Takeaway:** Types don’t protect you at runtime. Use **runtime validation** (e.g., Zod) at boundaries.

---

## 4) Why types catch bugs early (and what they don’t do)

### They **do** catch:

* **Wrong shapes** (`email` missing; `id` is number but expected string).
* **Null/undefined** issues (with `strictNullChecks`).
* **Exhaustiveness** (you forgot to handle a new variant).
* **API drift** (client/server type mismatch).

### They **don’t**:

* **Speed up** your code. (Performance is about algorithms, runtimes, bundlers.)
* **Replace tests**. Logic bugs still need tests.
* **Validate runtime data** (user input, JSON from network, env vars) without explicit checks.
* **Stop exceptions** thrown by your code; they only help you prevent many of them.

---

## 5) Bonus: Exhaustiveness with discriminated unions

### Code probe H — compiler as reviewer

```ts
type Circle = { kind: "circle"; r: number };
type Square = { kind: "square"; s: number };
type Shape = Circle | Square;

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle": return Math.PI * shape.r * shape.r;
    case "square": return shape.s * shape.s;
    default: {
      const _exhaustive: never = shape; // if a new kind is added, compiler errors here
      return _exhaustive;
    }
  }
}
```

Add a new variant (e.g., `Triangle`) and watch the compiler **force** you to handle it.

---

## 6) Mini-drills (10–15 min)

1. **Shape compatibility:**
   Define `type A = { id: string; tags: string[] }` and `type B = { id: string; tags: string[] }`.
   Assign `A` to `B` and vice versa (OK). Then add `createdAt: Date` to `A` only.
   Which assignments still compile? Why?

2. **Inference tweaks:**
   Create `const colors = ["red", "green", "blue"] as const;`
   Make a function `paint(c: typeof colors[number])`.
   Try calling `paint("purple")` (should error). Explain the inferred type.

3. **Erasure reality check:**
   Write a function `sum(a: number, b: number): number`.
   Force a bad call with `(123 as any, "4" as any)`.
   Show that the runtime result is `"1234"` if you accidentally coerce to strings.
   Explain why TS didn’t stop it (you used `any`).

---

## 7) Quick self-check

* Can you explain **structural typing** in one sentence?
* When do you **annotate** vs rely on **inference**?
* What is **type erasure**, and why does it mean you still need **runtime validation**?

---

## 8) Where this matters next

* We’ll lean on **inference** inside modules for brevity, but **annotate boundaries** (public functions, API shapes).
* We’ll use **discriminated unions** and **exhaustive switches** for reducers and RPC results.
* We’ll add **Zod** later to validate inputs/outputs at runtime so “erasure” doesn’t bite us.

